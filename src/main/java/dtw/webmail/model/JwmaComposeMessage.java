/**** jwma Java WebMail* Copyright (c) 2000-2003 jwma team** jwma is free software; you can distribute and use this source* under the terms of the BSD-style license received along with* the distribution. ***/package dtw.webmail.model;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.io.Serializable;import java.util.ArrayList;import java.util.Arrays;import java.util.Date;import java.util.Enumeration;import java.util.List;import javax.activation.DataHandler;import javax.activation.DataSource;import javax.activation.FileDataSource;import javax.mail.Address;import javax.mail.BodyPart;import javax.mail.Flags;import javax.mail.Folder;import javax.mail.Header;import javax.mail.Message;import javax.mail.MessagingException;import javax.mail.Multipart;import javax.mail.Part;import javax.mail.Session;import javax.mail.internet.InternetAddress;import javax.mail.internet.MimeBodyPart;import javax.mail.internet.MimeMessage;import javax.mail.internet.MimeMultipart;import javax.mail.internet.MimeUtility;import javax.mail.util.ByteArrayDataSource;import org.apache.log4j.Logger;import org.springframework.web.multipart.MultipartFile;import com.eazytec.bpm.common.util.StringUtil;import dtw.webmail.JwmaSession;import dtw.webmail.util.EntityHandler;import dtw.webmail.util.MimeBodyPartDataSource;/** * Class implementing the JwmaComposeMessage model. * <p> * This implementation is specialized to wrap a * <tt>javax.mail.Message</tt> for composing. * * @author Dieter Wimberger * @version 0.9.7 07/02/2003 */public class JwmaComposeMessage implements JwmaMessage, Serializable {  //logging  private static Logger log = Logger.getLogger(JwmaComposeMessage.class);  //instance attributes  private boolean m_Reply;  private boolean m_Forward;  private boolean m_Draft;  private StringBuffer m_Body;  private MimeMessage m_Message;  private MimeMultipart m_Attachments;  private boolean m_Singlepart = true;  private JwmaDisplayMessage m_RepliedMessage;  private boolean m_InvisibleToList = false;  private JwmaMessagePart[] m_Parts;  private int m_Number = -1;  /**   * Constructs a <tt>JwmaComposeMessage</tt> instance.   */  private JwmaComposeMessage() {  }//constructor  public MimeMultipart getAttachments(){	  return m_Attachments;  }    /**   * Constructs a <tt>JwmaComposeMessage</tt> instance.   *   * @param msg the aggregated <tt>MimeMessage</tt>.   */  private JwmaComposeMessage(MimeMessage msg) {    m_Message = msg;    m_Attachments = new MimeMultipart();    m_Parts = new JwmaMessagePart[0];    try {      m_Message.setHeader("X-Mailer", X_MAILER_STRING);    } catch (Exception ex) {    }  }//constructor  public String getFullHeader() {    StringBuffer fullhead = new StringBuffer();    try {      for (Enumeration enumeration = m_Message.getAllHeaderLines();      	enumeration.hasMoreElements();) {        fullhead.append((String) enumeration.nextElement())            .append("\n");      }    } catch (MessagingException mex) {    }    return fullhead.toString();  }//getFullHeader  public int getMessageNumber() {    return m_Number;  }//getMessageNumber  public void setMessageNumber(int nr) {    m_Number = nr;  }//setMessageNumber  public Date getReceivedDate() {    return null;  }//getDate  public Date getSentDate() {    return null;  }//getSentDate  public Date getDate() {    return null;  }//getDate  public boolean isSent() {    return false;  }//isSent  public boolean isReceived() {    return false;  }//isReceived  /**   * Tests if the message is a reply.   *   * @return true if the message is a reply,   *         false otherwise.   */  public boolean isReply() {    return m_Reply;  }//isReply  public boolean isDraft() {    return m_Draft;  }//isDraft  /**   * Flags the message as a forward.   *   * @param true if the message is a forward,   *         false otherwise.   */  private void setForward(boolean b) {    m_Forward = b;  }//setForward  /**   * Flags the message as a reply.   *   * @param true if the message is a reply,   *         false otherwise.   */  private void setReply(boolean b) {    m_Reply = b;  }//setReply  /**   * Flags the message as a draft.   *   * @param true if the message is a draft,   *         false otherwise.   */  public void setDraft(boolean b) {    m_Draft = b;  }//setDraft  /**   * Sets the message that is being replied to.   * In case the message gets send, this can be   * used to set the answered flag.   * Normally this is done by calling reply in the JavaMail API,   * but as the folder is not open in READ_WRITE mode,   * and even if it was, the message might never get send,   * this is the consistent way.   */  private void setRepliedMessage(JwmaDisplayMessage msg) {    m_RepliedMessage = msg;  }//setRepliedMessage  public String getFrom() {    try {      return EntityHandler.encode(          InternetAddress.toString(m_Message.getFrom())      );    } catch (Exception ex) {      return "";    }  }//getFrom  /**   * Set the sender(s) address of the message.   *   * @param from the sender(s) address of the message   *        as <tt>String</tt>.   */  public void setFrom(String from) {    try {      m_Message.setFrom(new InternetAddress(from));    } catch (Exception ex) {    }  }//setFrom    /**   * Set the sender(s) address of the message.   *   * @param from the sender(s) address of the message   *        as <tt>String</tt>.   */  public void setFrom(String from, String name) {    try {    	InternetAddress fromAddr = new InternetAddress(from);    	fromAddr.setPersonal(name, "UTF-8");    	m_Message.setFrom(fromAddr);    } catch (Exception ex) {    }  }//setFrom  public String getReplyTo() {    try {      return InternetAddress.toString(m_Message.getReplyTo());    } catch (Exception ex) {      return "";    }  }//getReplyTo  /**   * Set the Reply-To address(es) of the message.   *   * @param from the Reply-To address(es) of the message   *        as <tt>String</tt>.   */  public void setReplyTo(String from) {    try {      m_Message.setReplyTo(InternetAddress.parse(from));    } catch (Exception ex) {    }  }//setReplyTo  public String getTo() {    String str = "";    try {      str = InternetAddress.toString(m_Message.getRecipients(Message.RecipientType.TO));      if (str == null) {        str = "";      }    } catch (Exception ex) {      return str;    }    return str;  }//getTo  /**   * Sets the receiver's address(es) of the message as   * <tt>String</tt>.   *   * @param to the receiver(s) address(es) of the message as String.   *   * @throws MessagingException if the receiver's address(es) is (are) malformed.   */  public void setTo(String to)      throws MessagingException {    if (to == null || to.equals("")) {      return;    } else {		Folder f = m_Message.getFolder();		if(f != null){            f.open(Folder.READ_WRITE);            m_Message = new MimeMessage(m_Message);            m_Message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(to));            f.close(false);		} else {			m_Message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(to));		}    }  }//setTo    /**   * Sets the receiver's address(es) of the message as   * <tt>String</tt>.   *   * @param to the receiver(s) address(es) of the message as String.   *   * @throws MessagingException if the receiver's address(es) is (are) malformed.   */  public void setTo(Address[] to)      throws MessagingException {    if (to == null || to.equals("")) {      return;    } else {		Folder f = m_Message.getFolder();		if(f != null){            f.open(Folder.READ_WRITE);            m_Message = new MimeMessage(m_Message);            m_Message.setRecipients(Message.RecipientType.TO, to);            f.close(false);		} else {			m_Message.setRecipients(Message.RecipientType.TO, to);		}    }  }//setTo  private void setTo(Address to) throws MessagingException {    m_Message.setRecipient(Message.RecipientType.TO, to);  }//setTo  public boolean isInvisibleToList() {    return m_InvisibleToList;  }//isInvisibleToList  public void setInvisibleToList(boolean invisibleToList) {    m_InvisibleToList = invisibleToList;  }//setInvisibleToList  public String getCCTo() {    String str = "";    try {      str = InternetAddress.toString(m_Message.getRecipients(Message.RecipientType.CC));      if (str == null) {        str = "";      }    } catch (Exception ex) {      return str;    }    return str;  }//getCCTo  /**   * Sets the carbon copy receiver's address(es) of the message.   *   * @param to the carbon copy receiver(s) address(es) of the   *        message as String.   *   * @throws MessagingException if the carbon copy receiver's address(es)   *         is (are) malformed.   */  public void setCCTo(String ccto)      throws MessagingException {    m_Message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(ccto));  }//setCCTo;  /**   * Sets the carbon copy receiver's address(es) of the message.   *   * @param to the carbon copy receiver(s) address(es) of the   *        message as String.   *   * @throws MessagingException if the carbon copy receiver's address(es)   *         is (are) malformed.   */  public void setCCTo(Address[] ccto)      throws MessagingException {    m_Message.setRecipients(Message.RecipientType.CC, ccto);  }//setCCTo;    public String getBCCTo() {    String str = "";    try {      str = InternetAddress.toString(m_Message.getRecipients(Message.RecipientType.BCC));      if (str == null) {        str = "";      }    } catch (Exception ex) {      return str;    }    return str;  }//getBCCTo  /**   * Sets the blind carbon copy receiver's address(es) of the message.   *   * @param to the blind carbon copy receiver(s) address(es) of the   *        message as String.   *   * @throws MessagingException if the blind carbon copy receiver's address(es)   *         is (are) malformed.   */  public void setBCCTo(String bccto)      throws MessagingException {    m_Message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(bccto));  }//setBCCTo;  public String getSubject() {    String str = "";    try {      str = MimeUtility.decodeText(m_Message.getSubject());      if (str == null) {        str = "";      }    } catch (Exception ex) {      return str;    }    return str;  }//getSubject      /**   * Sets the blind carbon copy receiver's address(es) of the message.   *   * @param to the blind carbon copy receiver(s) address(es) of the   *        message as String.   *   * @throws MessagingException if the blind carbon copy receiver's address(es)   *         is (are) malformed.   */  public void setBCCTo(Address[] bccto)      throws MessagingException {    m_Message.setRecipients(Message.RecipientType.BCC, bccto);  }//setBCCTo;  /**   * Sets the subject of the message.   *   * @param subject the subject of the message as <tt>String</tt>.   *   * @throws JwmaException if the string is malformed (encoding, null).   */  public void setSubject(String subject)      throws JwmaException {    try {      if (subject != null) {        m_Message.setSubject(MimeUtility.encodeText(subject));      } else {        m_Message.setSubject("");      }    } catch (Exception ex) {    }  }//setSubject  public String getBody() {    if (m_Body == null || m_Body.length() == 0) {      return "";    } else {      return m_Body.toString();    }  }//getBody  /**   * Sets the body of the message.   * <p>   * Note that the body will be the text/plain content of   * a singlepart message, and attached as text/plain part to   * a multipart message.   *   * @param body the text/plain content of the message as   *        <tt>String</tt>.   */  public void setBody(String body) {    if (body != null) {      m_Body = new StringBuffer(body);    } else {      m_Body = new StringBuffer();    }  }//setBody  /**   * Appends to the body of the message.   *   * @param str more text/plain content for the   *        message as <tt>String</tt>.   */  public void appendBody(String str) {    if (m_Body == null) {      m_Body = new StringBuffer(str);    } else {      m_Body.append(str);    }  }//appendBody  /**   * Adds attachments to this <tt>JwmaComposeMessage</tt>.   *   * @param mmp the <tt>MimeMultipart</tt> that represents the   *        attachments.   */  public void addAttachments(MimeMultipart mmp) {    try {      for (int i = 0; i < mmp.getCount(); i++) {        m_Attachments.addBodyPart((MimeBodyPart) mmp.getBodyPart(i));      }      m_Singlepart = false;    } catch (Exception ex) {      log.error("addAttachments()", ex);    }  }//addAttachments    /**   * Adds attachments to this <tt>JwmaComposeMessage</tt>.   *   * @param mmp the <tt>MimeMultipart</tt> that represents the   *        attachments.   */  public void addForwardAttachments(MimeMultipart mmp, String[] removedAttachments) {	  try {		/*  int removeId = 0;		  List<String> arrayList = Arrays.asList(removedAttachments);		  if(arrayList.contains("0")){			  List<String> remove = new ArrayList<String>();			  remove.add("0");			  arrayList.remove(remove);			  removeId = 1;		  }		  System.out.println(" List Of Remoce ==   "+removedAttachments.toString());		  String [] removeAttachments = arrayList.toArray(new String[arrayList.size()]);		  System.out.println(" ****************   "+removeAttachments.toString());		  boolean isRemoved = false;		  for (int i = removeId; i < mmp.getCount(); i++) {			  for(int j=0; j<removeAttachments.length; j++){				  if(Integer.parseInt(removeAttachments[j])-1 != i){					  isRemoved = true;				  }			  }			  if(isRemoved){				  m_Attachments.addBodyPart((MimeBodyPart) mmp.getBodyPart(i));				  isRemoved = false;			  }		  }*/		  boolean isRemoved = false;		  List<String> removedAttachmentList = Arrays.asList(removedAttachments);		  for(int i=0; i< mmp.getCount(); i++){			 /* for(int j=0; j<removedAttachments.length; j++){				  if(Integer.parseInt(removedAttachments[j]) == i){					  isRemoved = true;				  }			  }*/	  		  if(!removedAttachmentList.contains(String.valueOf(i))){				  isRemoved = true;			  }			  if(isRemoved){				  m_Attachments.addBodyPart((MimeBodyPart) mmp.getBodyPart(i));				  isRemoved = false;			  }		  }		  m_Singlepart = false;	  } catch (Exception ex) {		  log.error("addAttachments()", ex);	  }  }//addAttachments    public boolean isSinglepart() {    return m_Singlepart;  }//isSinglepart  public boolean isMultipart() {    return !m_Singlepart;  }//isMultipart  public JwmaMessagePart[] getMessageParts() {    return m_Parts;  }//getMessageParts  public void setMessageParts(JwmaMessagePart[] m_parts) {	    this.m_Parts = m_parts;	  }//getMessageParts    /**   * Returns the <tt>Message</tt> instance associated   * with this <tt>JwmaComposeMessage</tt>.   *   * @return associated <tt>Message</tt> instance.   */  public Message getMessage() {    return m_Message;  }//getMessage  public void setAttachements(List<MultipartFile> files, JwmaMessagePart[] mparts) throws MessagingException, IOException, JwmaException{	  int mpartsSize = 0;	  if(mparts != null ){		  mpartsSize = mparts.length;		  int arraySize = mpartsSize+files.size();		  m_Parts = new JwmaMessagePart[arraySize];		  for(int i=0; i<mparts.length; i++){			  m_Parts[i] = mparts[i]; 		  }	  }	  for(MultipartFile file : files){		  if(file != null && !file.getOriginalFilename().isEmpty()){			  DataSource source = new ByteArrayDataSource(file.getInputStream(), file.getContentType());			  BodyPart messageBodyPart = new MimeBodyPart();			  messageBodyPart.setFileName(MimeUtility.encodeText(file.getOriginalFilename()));			  messageBodyPart.setDataHandler(new DataHandler(source));			  messageBodyPart.setHeader("Content-Type", file.getContentType());			  messageBodyPart.setHeader("Content-ID", file.getOriginalFilename());			  messageBodyPart.setHeader("Content-Transfer-Encoding", "base64");			  messageBodyPart.setDisposition(Part.INLINE);			  m_Attachments.addBodyPart(messageBodyPart);			  m_Parts[mpartsSize] = JwmaMessagePartImpl.createJwmaMessagePartImpl(messageBodyPart, mpartsSize);			  m_Singlepart = false;			  mpartsSize++;		  }	  }  }    public void setForwardAttachements(Multipart mp, Folder folder) throws MessagingException, IOException{	  for(int i = 0; i < mp.getCount(); i++) {		  DataSource source = new ByteArrayDataSource(mp.getBodyPart(i).getInputStream(), mp.getContentType());		  String fileName = mp.getBodyPart(i).getFileName();		  if(null != fileName){			  BodyPart messageBodyPart = new MimeBodyPart();			  messageBodyPart.setFileName(fileName);			  messageBodyPart.setDataHandler(new DataHandler(source));	          m_Attachments.addBodyPart(messageBodyPart);			  m_Singlepart = false;		  }      }	   }    /**   * Sends this instance via the standard convenience <tt>Transport.send()</tt>.   * <p>   * Asserts that a sender is set, and creates either a multipart   * or a singlepart <tt>Message</tt> from the data stored   * in this instance.   *   * @throws JwmaException If there is no sender, or if sending fails.   */  public void send(JwmaSession ses) throws JwmaException {    try {      //Assert that a valid sender identity is set.      if (getFrom() == null || getFrom().equals("")) {        throw new JwmaException("jwma.composemessage.send.sendermissing", true);      }      //m_Message.setContent(m_Attachments);     /* String filename = "/home/ideas2it57/Attendance.html";            BodyPart messageBodyPart = new MimeBodyPart();      messageBodyPart.setText("Here's the file");            Multipart multipart = new MimeMultipart();      multipart.addBodyPart(messageBodyPart);      messageBodyPart = new MimeBodyPart();      DataSource source = new FileDataSource(filename);      messageBodyPart.setDataHandler(new DataHandler(source));      messageBodyPart.setFileName(filename);      multipart.addBodyPart(messageBodyPart);      m_Message.setContent(multipart);*/            //set content either single or multipart      if (isMultipart()) {        //body represents the first part        if (getBody() != null && getBody().length() > 0) {          MimeBodyPart bodypart = new MimeBodyPart();          //bodypart.setText(getBody());          bodypart.setContent(getBody(),"text/html; charset=utf-8");          m_Attachments.addBodyPart(bodypart, 0);        }        //set the content        m_Message.setContent(m_Attachments);        //m_Message.setContent(getBody(), "text/html");      } else {          m_Message.setContent(getBody(), "text/html; charset=utf-8");          //m_Message.setText(getBody());      }      //transport the message      if (isInvisibleToList()) {        log.debug("send()::" + "sending message seperately to receivers on list.");        InternetAddress[] tos =            (InternetAddress[]) m_Message.getRecipients(Message.RecipientType.TO);        for (int i = 0; i < tos.length; i++) {          setTo(tos[i]);          ses.getJwmaTransport().sendMessage(m_Message);        }        //reset tos to remember for saving        m_Message.setRecipients(Message.RecipientType.TO, tos);      } else {        ses.getJwmaTransport().sendMessage(m_Message);      }      //flag the message as answered      try {        if (isReply() && m_RepliedMessage != null) {          Message msg = m_RepliedMessage.getMessage();          Folder fld = msg.getFolder();          fld.open(Folder.READ_WRITE);          msg.setFlag(Flags.Flag.ANSWERED, true);          fld.close(false);        }      } catch (MessagingException mex) {        log.error("Failed to send message", mex);        //JwmaKernel.getReference().debugLog().writeStackTrace(mex);      }    } catch (MessagingException mex) {    	mex.printStackTrace();      throw new JwmaException("jwma.composemessage.send.failed", true)          .setException(mex);    }  }//send  /**   * Sends this instance via the standard convenience <tt>Transport.send()</tt>.   * <p>   * Asserts that a sender is set, and creates either a multipart   * or a singlepart <tt>Message</tt> from the data stored   * in this instance.   *   * @throws JwmaException If there is no sender, or if sending fails.   */  public void setMessageContent(JwmaSession ses) throws JwmaException {    try {      if (getFrom() == null || getFrom().equals("")) {        throw new JwmaException("jwma.composemessage.send.sendermissing", true);      }      if (isMultipart()) {        if (getBody() != null && getBody().length() > 0) {          MimeBodyPart bodypart = new MimeBodyPart();          bodypart.setContent(getBody(),"text/html; charset=utf-8");          m_Attachments.addBodyPart(bodypart, 0);        }        m_Message.setContent(m_Attachments);      } else {          m_Message.setContent(getBody(), "text/html; charset=utf-8");      }    } catch (MessagingException mex) {    	mex.printStackTrace();      throw new JwmaException("jwma.composemessage.send.failed", true)          .setException(mex);    }  }//send    public void openDraft(JwmaStoreImpl store) throws JwmaException {    log.debug("openDraft()");    try {      if (isDraft()) {        //existing draft will be updated        //this should ensure the message is fetched RW?!        Folder f = m_Message.getFolder();        f.open(Folder.READ_WRITE);        //mark old deleted        m_Message.setFlag(Flags.Flag.DELETED, true);        m_Message = new MimeMessage(m_Message);        f.close(false);      } //else {      //new draft will be appended      //get the folder      // Folder draft = store.getDraftFolder();      //open it read write      //draft.open(Folder.READ_WRITE);      //}    } catch (Exception ex) {      log.error("openDraft()", ex);      throw new JwmaException("jwma.composemessage.draft.openfailed");    }  }//openDraft  public void closeDraft(JwmaStoreImpl store) throws JwmaException {    //log.debug("closeDraft()");    try {      //Assert that a valid sender identity is set.      if (getFrom() == null || getFrom().equals("")) {        throw new JwmaException("jwma.composemessage.sendermissing", true);      }      //set content either single or multipart      if (isMultipart()) {        //body represents the first part        if (getBody() != null && getBody().length() > 0) {          MimeBodyPart bodypart = new MimeBodyPart();          bodypart.setText(getBody());          m_Attachments.addBodyPart(bodypart, 0);        }        //set the content        m_Message.setContent(m_Attachments);      } else {        m_Message.setText(getBody());      }      //set draft flag      m_Message.setFlag(Flags.Flag.DRAFT, true);      m_Message.saveChanges();      Folder draft = store.getDraftFolder();      if(draft == null){    	  //store.prepareDraftFolder();    	  //draft = store.getDraftFolder();    	 JwmaFolderImpl jwmaFolder = store.getInboxDraftFolder();     	 if( jwmaFolder == null){     		store.prepareDraftFolder();     		jwmaFolder=store.getInboxDraftFolder();   	     }     	  draft = jwmaFolder.getFolder();//store.getFolder("INBOX"+store.getFolderSeparator()+"Draft");      }      draft.open(Folder.READ_WRITE);      Message[] tosave = {m_Message};      draft.appendMessages(tosave);      m_Message = new MimeMessage(m_Message);      draft.close(true);    } catch (Exception ex) {      log.error("closeDraft()", ex);      throw new JwmaException("jwma.composemessage.draft.failed", true);    }  }//closeDraft  /**   * Prepares the message instance, specifically for forwarding and replying,   * were the content probably has to be copied into the message to be   * composed.   * A copy of multi-parts will be attached to a forward if requested.   *   * @param msg the <tt>JwmaDisplayMessage</tt> instance that is replied   *        to or forwarded.   * @param prefs the <tt>JwmaPreferences</tt> instance associated with the   *        actual user (for settings).   * @param togglequote the flag that can toggle the setting from the user's   *        preferences.   * @param attfwd the flag that toggles whether attachments are forwarded   *        with this message.   *   * @throws JwmaException if there is a failure on accessing or quoting the   *          given message's content.   */  private void prepare(JwmaDisplayMessage msg, JwmaPreferences prefs,                       boolean togglequote, boolean attfwd)      throws JwmaException {    if (!m_Forward) {      log.debug("Reply");      setSubject("Re: " + (msg.getSubject() != null ? msg.getSubject() : "(no subject)"));      //transfer quoted text if applicable      //there is a little bit of logic in the if ;)      if (prefs.isAutoQuote() != togglequote) {        //FIXME!!!        //replace for textproc processor        //and add On blah blah wrote....        //retrieve the quotechar        String quotechar = prefs.getQuoteChar();        //Quote singlepart mail        if (msg.isSinglepart()) {          //log.debug("Quoting single part message");          String messtr = msg.getBody();          StringBuffer rbodybuf = new StringBuffer(messtr.length() + 10);          rbodybuf.append("\n\n");          rbodybuf.append(quotechar);          boolean done = false;          int pos = 0;          int foundpos = 0;          while (!done) {            foundpos = messtr.indexOf(10, pos);            if (foundpos != -1) {              rbodybuf.append(messtr.substring(pos, foundpos + 1));              rbodybuf.append(quotechar);              pos = foundpos + 1;            } else {              rbodybuf.append(messtr.substring(pos, messtr.length()));              done = true;            }          }          this.appendBody(rbodybuf.toString());          rbodybuf = null;          messtr = null;        } else {          //log.debug("Quoting multi part message (text parts).");          JwmaMessagePart[] mparts = msg.getMessageParts();          //quote text parts of multipart messages          for (int i = 0; i < mparts.length; i++) {            JwmaMessagePartImpl part = (JwmaMessagePartImpl) mparts[i];            if (part.isMimeType("text/plain")) {              //FIXME: Process to make quoted              this.appendBody(part.getTextContent());            }          }        }      }    } else {      //log.debug("Forwarding message.");      setSubject("Fwd: " + (msg.getSubject() != null ? msg.getSubject() : "(no subject)"));      if (msg.isSinglepart()) {        //FIXME: process to make quote        this.appendBody(msg.getBody());        //log.debug("Quoting single part message");      } else {        if (attfwd) {          //log.debug("Forwarding message with attachments.");          JwmaMessagePart[] mparts = msg.getMessageParts();          try {            //1. get MimeMultiPart            MimeMultipart mmp = (MimeMultipart) msg.getMessage().getContent();            MimeMultipart nmmp = new MimeMultipart();            ArrayList nonplaintextparts = new ArrayList(mmp.getCount());            //2. copy over contents            for (int i = 0; i < mmp.getCount() && i < mparts.length; i++) {            	if(mparts[i] != null){		              if (mparts[i].isMimeType("text/plain")) {		                //FIXME: process to make quote?		                this.appendBody(((JwmaMessagePartImpl) mparts[i]).getTextContent());		                //log.debug("Forwarding message: quoted plain text attachment.");		              } else if(mparts[i].isMimeType("text/html") && mparts[i].getName() == null){		            	  this.appendBody(((JwmaMessagePartImpl) mparts[i]).getTextContent());		              } else {		                MimeBodyPart mbp = (MimeBodyPart) mmp.getBodyPart(i);		                MimeBodyPart nmbp = new MimeBodyPart();		                //copy all headers		                for (Enumeration enumeration = mbp.getAllHeaders(); enumeration.hasMoreElements();) {		                  Header h = (Header) enumeration.nextElement();		                  nmbp.setHeader(h.getName(), h.getValue());		                }				                //copy content		                InputStream in = mbp.getInputStream();		                /*String[] encoding = mbp.getHeader("Content-Transfer-Encoding");		                if (encoding != null && encoding.length > 0) {		                   in = MimeUtility.decode(in, encoding[0]);		                }		                */		                ByteArrayOutputStream bout = new ByteArrayOutputStream();		                OutputStream out = (OutputStream) bout;		                byte[] buffer = new byte[10240];		                int amount = 0;		                while ((amount = in.read(buffer)) >= 0) {		                  out.write(buffer, 0, amount);		                }		                out.flush();		                out.close();				                //create the datasource		                MimeBodyPartDataSource mbpds =		                    new MimeBodyPartDataSource(		                        mparts[i].getContentType(), mparts[i].getName(), bout.toByteArray()		                    );		                nmbp.setDataHandler(new DataHandler(mbpds));		                //ensure transfer encoding is set		                nmbp.setHeader("Content-Transfer-Encoding", "base64");		                nmmp.addBodyPart(nmbp);		                nonplaintextparts.add(mparts[i]);		                //log.debug("Forwarding message: added attachment and partinfo.");		              }            	}          }            //copy over non plain text message part infos            m_Parts = new JwmaMessagePart[nonplaintextparts.size()];            m_Parts = (JwmaMessagePart[]) nonplaintextparts.toArray(m_Parts);            //3. append message's attachments to this message            this.addAttachments(nmmp);          } catch (Exception ex) {        	  ex.printStackTrace();            throw new JwmaException("jwma.composemessage.failedattforward").setException(ex);          }        } else {          //log.debug("Forwarding message without attachments.");          JwmaMessagePart[] mparts = msg.getMessageParts();          //quote text parts of multipart messages          for (int i = 0; i < mparts.length; i++) {            JwmaMessagePartImpl part = (JwmaMessagePartImpl) mparts[i];            if (part.isMimeType("text/plain")) {              //FIXME: Process to make quoted              this.appendBody(part.getTextContent());              //log.debug("Forwarding message woa: quoted plain/text part.");            }          }        }      }    }   /* try{    //set sender identity from the active mailidentity    String from = prefs.getMailIdentity().getFrom();    if (from == null || from.length() == 0) {      from = prefs.getFirstname() + " " + prefs.getLastname() +          " <" + prefs.getUserIdentity() + ">";      setFrom(from);    }    } catch (Exception e) {		// TODO: handle exception    	e.printStackTrace();	}*/  }//prepare  /**   * Creates a <tt>JwmaComposeMessage</tt> instance.   * <p>This factory method should be used to create new instances   * of <tt>JwmaComposeMessage</tt>, which are not a reply to   * an already existing message.   *   * @param ses the mail <tt>Session</tt> the message is created within.   * @return the newly created instance.   */  public static JwmaComposeMessage createJwmaComposeMessage(Session ses) {    JwmaComposeMessage message = null;    message = new JwmaComposeMessage(new MimeMessage(ses));    message.setReply(false);    return message;  }//createJwmaComposeMessage  /**   * Creates a <tt>JwmaComposeMessage</tt> instance.   * <p> This factory method should be used to create new instances   * of <tt>JwmaComposeMessage</tt>, which are a reply to   * an already existing message.   * <p>The reply will address the sender, and if flagged, also all   * recipients of the original <tt>Message</tt>.   *   *   * @param msg the <tt>Message</tt> to be replied.   * @param toall a flag determining wheter the reply should address also all   *        recipients of the original <tt>Message</tt>.   * @return the newly created instance.   * @throws JwmaException if it fails to create the new instance.   */  public static JwmaComposeMessage createReply(JwmaDisplayMessage msg, boolean toall,                                               JwmaPreferences prefs, boolean togglequote)      throws JwmaException {    JwmaComposeMessage message = null;    try {      message = new JwmaComposeMessage(          (MimeMessage) msg.getMessage().reply(toall)      );      message.setRepliedMessage(msg);      message.setReply(true);      message.prepare(msg, prefs, togglequote, false);    } catch (MessagingException mex) {      throw new JwmaException("jwma.composemessage.failedcreation", true)          .setException(mex);    }    return message;  }//createReply  /**   * Creates a <tt>JwmaComposeMessage</tt> instance.   * <p> This factory method should be used to create new instances   * of <tt>JwmaComposeMessage</tt>, which are a reply to   * an already existing message.   * <p>The reply will address the sender, and if flagged, also all   * recipients of the original <tt>Message</tt>.   *   *   * @param msg the <tt>Message</tt> to be replied.   * @param toall a flag determining wheter the reply should address also all   *        recipients of the original <tt>Message</tt>.   * @return the newly created instance.   * @throws JwmaException if it fails to create the new instance.   */  public static JwmaComposeMessage createForward(Session ses,                                                 JwmaDisplayMessage msg, String to,                                                 JwmaPreferences prefs, boolean togglequote,                                                 boolean attfwd)      throws JwmaException {    log.debug("createForward()");    JwmaComposeMessage message = createJwmaComposeMessage(ses);    try {      message.setForward(true);      message.setTo(to.replace("&lt;", "<").replace("&gt;", ">"));      //Folder fld = msg.getMessage().getFolder();     // fld.open(Folder.READ_ONLY);      message.prepare(msg, prefs, togglequote, attfwd);    //  fld.close(false);    } catch (MessagingException mex) {      throw new JwmaException("jwma.composemessage.failedcreation", true)          .setException(mex);    }    return message;  }//createReply  public static JwmaComposeMessage createDraft(Message msg)      throws JwmaException {    JwmaComposeMessage message = new JwmaComposeMessage(        (MimeMessage) msg    );    try {      message.setDraft(true);      message.setMessageNumber(msg.getMessageNumber());      message.setBody(msg.getContent().toString());          } catch (Exception ex) {      throw new JwmaException("jwma.composemessage.failedcreation", true)          .setException(ex);    }    return message;  }//createDraft  /**   * Creates a <tt>JwmaComposeMessage</tt> instance.   * <p> This factory method should be used to create new instances   * of <tt>JwmaComposeMessage</tt>, which are a reply to   * an already existing message.   * <p>The reply will address the sender, and if flagged, also all   * recipients of the original <tt>Message</tt>.   *   *   * @param msg the <tt>Message</tt> to be replied.   * @param toall a flag determining wheter the reply should address also all   *        recipients of the original <tt>Message</tt>.   * @return the newly created instance.   * @throws JwmaException if it fails to create the new instance.   */  public static JwmaComposeMessage createDraftMessage(Session ses,                                                 JwmaDisplayMessage msg,                                                 JwmaPreferences prefs, boolean togglequote,                                                 boolean attfwd)      throws JwmaException {    log.debug("createForward()");    JwmaComposeMessage message = createJwmaComposeMessage(ses);    try {      message.setDraft(true);      message.setTo(msg.getTo().replace("&lt;", "<").replace("&gt;", ">"));      if(!StringUtil.isEmptyString(msg.getCCTo())){    	  message.setCCTo(msg.getCCTo().replace("&lt;", "<").replace("&gt;", ">"));      } else {    	  message.setCCTo(msg.getCCTo());      }      if(!StringUtil.isEmptyString(msg.getBCCTo())){    	  message.setBCCTo(msg.getBCCTo().replace("&lt;", "<").replace("&gt;", ">"));      } else {    	  message.setBCCTo(msg.getBCCTo());      }      message.setMessageNumber(msg.getMessageNumber());      message.setSubject(msg.getSubject());      Folder fld = msg.getMessage().getFolder();      fld.open(Folder.READ_ONLY);      message.prepareDraft(msg, prefs, togglequote, attfwd);      fld.close(false);    } catch (MessagingException mex) {      throw new JwmaException("jwma.composemessage.failedcreation", true)          .setException(mex);    }    return message;  }//createReply  /**   * Prepares the message instance, specifically for forwarding and replying,   * were the content probably has to be copied into the message to be   * composed.   * A copy of multi-parts will be attached to a forward if requested.   *   * @param msg the <tt>JwmaDisplayMessage</tt> instance that is replied   *        to or forwarded.   * @param prefs the <tt>JwmaPreferences</tt> instance associated with the   *        actual user (for settings).   * @param togglequote the flag that can toggle the setting from the user's   *        preferences.   * @param attfwd the flag that toggles whether attachments are forwarded   *        with this message.   *   * @throws JwmaException if there is a failure on accessing or quoting the   *          given message's content.   */  private void prepareDraft(JwmaDisplayMessage msg, JwmaPreferences prefs,                       boolean togglequote, boolean attfwd)      throws JwmaException {	  if (msg.isSinglepart()) {	        //FIXME: process to make quote	        this.appendBody(msg.getBody());	        //log.debug("Quoting single part message");      } else {          //log.debug("Forwarding message with attachments.");          JwmaMessagePart[] mparts = msg.getMessageParts();          try {            //1. get MimeMultiPart            MimeMultipart mmp = (MimeMultipart) msg.getMessage().getContent();            MimeMultipart nmmp = new MimeMultipart();            ArrayList nonplaintextparts = new ArrayList(mmp.getCount());            //2. copy over contents            for (int i = 0; i < mmp.getCount() && i < mparts.length; i++) {            	if(mparts[i] != null){		              if (mparts[i].isMimeType("text/plain") && mparts[i].getName() == null) {		                //FIXME: process to make quote?		                this.appendBody(((JwmaMessagePartImpl) mparts[i]).getTextContent());		                //log.debug("Forwarding message: quoted plain text attachment.");		              } else if(mparts[i].isMimeType("text/html") && mparts[i].getName() == null){		            	  this.appendBody(((JwmaMessagePartImpl) mparts[i]).getTextContent());		              } else {		                MimeBodyPart mbp = (MimeBodyPart) mmp.getBodyPart(i);		                MimeBodyPart nmbp = new MimeBodyPart();		                //copy all headers		                for (Enumeration enumeration = mbp.getAllHeaders(); enumeration.hasMoreElements();) {		                  Header h = (Header) enumeration.nextElement();		                  nmbp.setHeader(h.getName(), h.getValue());		                }				                //copy content		                InputStream in = mbp.getInputStream();		                /*String[] encoding = mbp.getHeader("Content-Transfer-Encoding");		                if (encoding != null && encoding.length > 0) {		                   in = MimeUtility.decode(in, encoding[0]);		                }		                */		                ByteArrayOutputStream bout = new ByteArrayOutputStream();		                OutputStream out = (OutputStream) bout;		                byte[] buffer = new byte[10240];		                int amount = 0;		                while ((amount = in.read(buffer)) >= 0) {		                  out.write(buffer, 0, amount);		                }		                out.flush();		                out.close();				                //create the datasource		                MimeBodyPartDataSource mbpds =		                    new MimeBodyPartDataSource(		                        mparts[i].getContentType(), mparts[i].getName(), bout.toByteArray()		                    );		                nmbp.setDataHandler(new DataHandler(mbpds));		                //ensure transfer encoding is set		                nmbp.setHeader("Content-Transfer-Encoding", "base64");		                nmmp.addBodyPart(nmbp);		                nonplaintextparts.add(mparts[i]);		                //log.debug("Forwarding message: added attachment and partinfo.");		              }	            }          }            //copy over non plain text message part infos            m_Parts = new JwmaMessagePart[nonplaintextparts.size()];            m_Parts = (JwmaMessagePart[]) nonplaintextparts.toArray(m_Parts);            //3. append message's attachments to this message            this.addAttachments(nmmp);          } catch (Exception ex) {            throw new JwmaException("jwma.composemessage.failedattforward").setException(ex);          }      }  }//prepare    /**   * Defines the X-MAILER set by jwma.   * This can probably help one day to recognize special mailer features.   */  public static final String X_MAILER_STRING = "jwma";}//class JwmaComposeMessage