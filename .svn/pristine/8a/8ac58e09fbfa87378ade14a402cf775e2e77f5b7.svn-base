package com.licensekit;
import java.text.DecimalFormat;
   
public class LicenseDef
{
   private static final String[] permArray = {
      "%C|j&htFaL#rup$v8nZAyf}qcEV59YgBekzPD[]{10JTX2QmiMS7Kdx^Hs6U3boR",
      "p$0fuO3w!mY#l}^o8BsVIAxQkJZt][iF2Eg@jC|UbXhK5qM9Gz&DNc{vrLW7TaSH",
      "PNC8FErh3w{$kxJ}#[0sc1VSpI%Dqy!tTYUdX]65BfjOQ@RugH7bAL^zlGMm|ZKW",
      "HZcK7Qx}@uXLej$bB4^RPWw3&yNzpFodI1]Vlr![OJAG9|fY%vs8iSnahUE5D{mM",
      "2HznjId8Zr&pwEkvsUa6RS4}9mTFyQ^1fe%bV{0xMACKWXtNcGh@!Yg|Pli]7OLJ",
      "DC$pF[k7uW#O4cAsjXhN32m80gGZb@i1ntJUPq6^zVL}o9{aQ5|BRTE]Y&HrSIl%",
      "hJ]m5wORW&^oTKBsk3Gya12UlNrp9b#6Cn@f$Q[j!8EMvz4SegYF%q{Ix7}XVDi0",
      "@X2rKOoMR#1}7gkEdxA[v4QCDVe6T]Pw%N3F8UnY|{5$9iZ^SBhL&uyH!0jIzJmt",
      "YVcwC%hK2JGrRxf^a$pQb8utvPq|NXBILT]my4lF6[#zo&Ok9g@idEjeSAZ70}!1",
      "^qFbGY5Qu$E|jXUOh!v[ne{iKW4f@zmP&C#S0rTLxJoA2Ikdyg%a9l1BRN7}c6sD",
      "WmvLSx!^A%Bry|[gM1t}EPX7]OdoD6bKn3YcI&48kGjzaR{ieU$C@05uHsFpwN#V",
      "cy0rJBGvqwA8mxoNKUjL%X1fl4M{9WktC3Ya$HO]p}7SDRTgdQ|Eb#hZVI[@n^sF",
      "IKovVw90LRMH#scC^B%dZemxr@G51}T8yAWzha$!YS34F]Xkg7Pnf[it2bUjpuJl",
      "mQgpyjvTqrZl9nkucAW&VdM1%tJUCPx@b#zSFEsX672^$D80hYe54iGHfNRaw!]K",
      "Wu^}S5IiYCQs41khaBTKAL0Z[NMFJpP8|my@%3DbEc&6eoU!vjznq#]gR$Hw79dX",
      "5NYFG|31D]2X9cokzeOLZ@4giS[{IJa!C^TyQsP867RKlUjV$trwxEq&uWmnvh#d",
      "Ibn3X17QqdSRaT{]Nyl|gs#hUB2F5x%$^zPrYc&LVW!tZkEvoeCKj@f4mD[0pi6H",
      "E]4s17g3nt@0$}lx^Qr2ROzB8uFd6CV9jq5GAbSaTUyX&!hNZ{MpKH%L[o#|eWwf",
      "rn7jKQBO!fGkp}MV[P0#Rv5oSUlHc$61D]3CYgsba{8AeI%&LWtZ9wFxhEdzTu@2",
      "mEsC0ya}MB]@zJ9uvXwiqU3!{NcPpTrFIn5K#fk^L%eW|H7d$&jZoOxh4SDGYlR1",
      "LS[Y$x@H6ZVe#k4I9U8FWCi7ar|dc5nqlXP{^R3&tAvDGMw1NhJbgf}0QB!zsuyK",
      "724a!D0$Fs8xrp|M[}1U^#u6jmhnGboAP]tLd3gO&qRiCKTe%JZNEIlQk59yw{@z",
      "Gx^CE!%6dL|fO7lb&oZ2uzcPa{4AUp$@IKTNr5q}tY3vJXgM[FH8y0B91]kwRQSh",
      "BIlKPoCqT6@vaH|Qd489m#r%tnswJ0ig]5GUREFc1[uVXjSx}7k&LOzMW3f!eAy$",
      "P3#dY9Ua4ZpchuEOD8RrNTefJS$l5!}sV2bt[o7@Q{^iLjmM6xgBzW&FnKIvqC|A",
      "F@r8|}eEv&b{VitYOj9x5Q[gXMUp1BC!DZ^3fPqlc$LWmzuda4%HkoR6Kh7y#AJ2",
      "0f%M]7YuKFz[V6GkCLv2qw{hjSmAN}xIW#UlRd$rOeXa&c!^T@3BgDn|ypZsJtbH",
      "2Qj[8tHJV}zo]y&Y3acO{fW$Ae6^R%L7|@0XiK#5GsN1ubFCn9SExUvrZDBpPIdm",
      "fSj8#t1F{c%zvm@|9M^ZPu3Xs!oqECnkJR2dhIaK]lHpN&iLU6xyGOT0w[V}br$W",
      "N0!mB8tXZxS2k$Quc6%KyVvRa{wp&q3lihM^#@4T[LP1AfH9O}GnC5DFzo|dYUrE",
      "CutQHLTrl1PUAZhdgRV#NF6$M%nJo{j[fY7IDOB|XmeSa^i&sv!c2b3G@}EK]Wk9",
      "|Mya%WCO&3mu1D^hdU5!xrvg[locPe4EjtAfq@QSBKL#XwJp{s2$IkH6F}bnRGVi"
   };
   private static final int PERM_ARRAY_CHECKSUM = 173594;
   private static final int ROLL_PERM_ARRAY = 43;

   private static final int[] hexArray = {
      30, 12, 26, 27, 25, 10, 15, 8,
      28, 2, 9, 6, 3, 13, 31, 7,
      16, 24, 0, 19, 4, 11, 14, 18,
      1, 20, 29, 17, 21, 22, 5, 23
   };
         
   final static int ML_NO = 0;
   final static int ML_YES = 1;
   final static int ML_FREE = 2;
   final static int ML_DEMO = 3;
   
   class ModuleLicense
   {
      int mode = ML_NO;          // one of ML_* values
      int exp_date_index = -1;   // 0..2 or -1 if forever
   }
   
   private ExpDate[] ed = {
      new ExpDate(),
      new ExpDate(),
      new ExpDate()
   };
   private ModuleLicense[] ml = {
      new ModuleLicense(),
      new ModuleLicense(),
      new ModuleLicense(),
      new ModuleLicense(),
      new ModuleLicense(),
      new ModuleLicense()
   };
   private char[] serial_char = { 'A', 'A' };   // 'A'..'Z', 'a'..'z' (2x)
   private int serial_number = 1;               // 1..9999
   private int version = 0;                     // 0..255
   private int aux_A = 0;                       // 0..255
   private int aux_B = 0;                       // 0..255
   private int aux_C = 0;                       // 0..7
   
  public LicenseDef()
   {
   }
   
   public int getMode (int index)
   {
      return ml[index].mode;
   }
   
   public void setMode (int index, int licenseMode) throws NumberFormatException
   {
      if ((licenseMode < ML_NO) || (licenseMode > ML_DEMO))
         throw new NumberFormatException("illegal license mode");
      ml[index].mode = licenseMode;
   }
   
   public int[] getMode ()
   {
      int[] mode = new int[6];
      
      for (int i = 0; i < 6; i++)
         mode[i] = ml[i].mode;
         
      return mode;
   }
   
   public void setMode (int licenseMode[]) throws NumberFormatException
   {
      for (int i = 0; i < 6; i++) {
         if (i < licenseMode.length) {
            if ((licenseMode[i] < ML_NO) || (licenseMode[i] > ML_DEMO))
               throw new NumberFormatException("illegal license mode");
            ml[i].mode = licenseMode[i];
         } else
            ml[i].mode = ML_NO;
      }
   }
   
   public int getExpDateIndex (int index)
   {
      return ml[index].exp_date_index;
   }
   
   public void setExpDateIndex (int index, int expDateIndex) throws NumberFormatException
   {
      if ((expDateIndex < -1) || (expDateIndex > 2))
         throw new NumberFormatException("illegal exp date index");
      ml[index].exp_date_index = expDateIndex;
   }
   
   public int[] getExpDateIndex ()
   {
      int[] exp_date_index = new int[6];
      
      for (int i = 0; i < 6; i++)
         exp_date_index[i] = ml[i].exp_date_index;
         
      return exp_date_index;
   }
   
   public void setExpDateIndex (int expDateIndex[]) throws NumberFormatException
   {
      for (int i = 0; i < 6; i++)
         if (i < expDateIndex.length) {
            if ((expDateIndex[i] < -1) || (expDateIndex[i] > 2))
               throw new NumberFormatException("illegal exp date index");
            ml[i].exp_date_index = expDateIndex[i];
         } else
            ml[i].exp_date_index = -1;
   }
   
   public ExpDate getExpDate (int index)
   {
      return new ExpDate(ed[index].year(), ed[index].month(), ed[index].day());
   }
   
   public void setExpDate (int index, ExpDate expDate)
   {
      ed[index] = new ExpDate(expDate.year(), expDate.month(), expDate.day());
   }
   
   public ExpDate[] getExpDate ()
   {
      ExpDate[] reted = new ExpDate[6];
      
      for (int i = 0; i < 6; i++)
         reted[i] = new ExpDate(ed[i].year(), ed[i].month(), ed[i].day());
      
      return reted;
   }
   
   public void setExpDate (ExpDate expDate[])
   {
      for (int i = 0; i < 6; i++) {
         if (i < expDate.length)
            ed[i] = new ExpDate(expDate[i].year(), expDate[i].month(), expDate[i].day());
         else
            ed[i] = new ExpDate();
      }
   }
   
   public String getUserID ()
   {
      String string = new String(serial_char);
      DecimalFormat df = new DecimalFormat("0000");
      
      string += df.format(serial_number);
      
      return string;
   }
   
   public int getSerialNumber(){
	   return serial_number;
   }
   
   
   public void setUserID (String string) throws NumberFormatException
   {
      char c0 = string.charAt(0);
      char c1 = string.charAt(1);
      int n = Integer.parseInt(string.substring(2));
      
      if (!(((c0 >= 'A') && (c0 <= 'Z')) || ((c0 >= 'a') && (c0 <= 'z'))))
         throw new NumberFormatException("illegal 1st char");
      if (!(((c1 >= 'A') && (c1 <= 'Z')) || ((c1 >= 'a') && (c1 <= 'z'))))
         throw new NumberFormatException("illegal 2nd char");
      if ((n < 1) || (n  > 9999))
         throw new NumberFormatException("illegal number part");
      
      serial_char[0] = c0;
      serial_char[1] = c1;
      serial_number = n;
   }
   
   public int getVersion ()
   {
      return version;
   }
   
   public void setVersion (int value) throws NumberFormatException
   {
      if ((value < 0) || (value > 255))
         throw new NumberFormatException("illegal version number");
      
      version = value;
   }
   
   public int getMaxUsers () throws NumberFormatException
   // obtain maxUsers (0..101) from aux_A value
   {     
      int maxUsers = (aux_A & 127) - 13;
      
      if ((maxUsers < 0) || (maxUsers > 101))
         throw new NumberFormatException("illegal maxUsers");
      
      return maxUsers;
   }

   public void setMaxUsers (int maxUsers) throws NumberFormatException
   // stuff maxUsers (0..101) into aux_A value
   {
      if ((maxUsers < 0) || (maxUsers > 101))
         throw new NumberFormatException("illegal maxUsers");
         
      aux_A = maxUsers + 13;  // store 13..114 to lower 7 bits
      
      // stuff random bit into aux_A's MSB

      int r = (int)(System.currentTimeMillis() / 1000);

      aux_A += ((r & 1) << 7) & 128;
   }
   
   public int getHostID () throws NumberFormatException
   // obtain aHostID (0..1023) from aux_B/C values
   {     
      int aHostID = aux_B + ((aux_C & 3) << 8);
      
      if ((aHostID < 0) || (aHostID > 1023))
         throw new NumberFormatException("illegal HostID");
      
      return aHostID;
   }

   public void setHostID (int aHostID) throws NumberFormatException
   // stuff aHostID (0..1023) into aux_B/C values
   {
      if ((aHostID < 0) || (aHostID > 1023))
         throw new NumberFormatException("illegal HostID");
         
      aux_B = aHostID & 255;        // store lower 8 bits of aHostID
         
      aux_C = (aHostID >>> 8) & 3;  // store upper 2 bits of aHostID
      
      // stuff random bits into aux_C's MSB

      int r = (int)(System.currentTimeMillis() / 1000);

      aux_C += ((r & 1) << 2) & 4;
   }
   
   public class InternalLicenseDef
   {
      class InternalExpDate
      {
         int day;        // 5b - 31..1 reversed, 0 error (random = forever)
         int month;      // 4b - 0..11, (13 = forever), else error
         int year;       // 5b - 0..31 from BASE_YEAR, (~day = forever)
         int check;      // 6b - ((day << 1) ^ year) | ~month
      }
      class InternalModuleLicense
      {
         int mode;       // 2b - 00 no, 01 yes, 10 free, 11 demo
         int index;      // 2b - 00 ed0, 01 ed1, 10 ed2, 11 forever
         int nm;         // 2b - ~mode
         int ni;         // 2b - ~index
         int mxi;        // 2b - mode ^ index
      }
      InternalExpDate[] ied = {
         new InternalExpDate(),
         new InternalExpDate(),
         new InternalExpDate()
      };              // 3 * 20 = 60b
      InternalModuleLicense[] iml = {
         new InternalModuleLicense(),
         new InternalModuleLicense(),
         new InternalModuleLicense(),
         new InternalModuleLicense(),
         new InternalModuleLicense(),
         new InternalModuleLicense()
      };              // 6 * 10 = 60b
      int serchar0;   // 6b - 0..25 == 'A'..'Z', 38..63 == 'a'..'z'; 26..37 err
      int serchar1;   // 6b - 0..25 == 'A'..'Z', 38..63 == 'a'..'z'; 26..37 err
      int sernum;     // 14b - 1..9999 == number; 0, 10000..16383 err
      int version;    // 8b - 0..255 
      int auxA;       // 8b - 0..255 single user license
      int auxB;       // 8b - 0..255 unlimited nw license
      int auxC;       // 3b - 0..7 nw lice #users
      int na;         // 8b - ~auxA
      int nb;         // 8b - ~auxB
      int nc;         // 3b - ~auxC
      // total 192b
      
      int numberOfWS; // workstation
      int numberOfLS; //location
      
      transient int[] val = new int[32];
      
      public InternalLicenseDef (LicenseDef ld)
      {
         int i;
         
         for (i = 0; i < 3; i++) {
            if (ld.ed[i].isDefined()) {
               ied[i].day = 31 - (ld.ed[i].day() - 1);
               ied[i].month = ld.ed[i].month() - 1;
               ied[i].year = ld.ed[i].year() - ExpDate.BASE_YEAR;
            } else {
               int r = (int)(System.currentTimeMillis() / 1000);
               ied[i].day = r & 31;
               ied[i].month = 13;
               ied[i].year = (~ied[i].day) & 31;
            }
            ied[i].check = ((((ied[i].day) << 1) ^ ied[i].year) | ~ied[i].month) & 63;
         }

         for (i = 0; i < 6; i++) {
            iml[i].mode = ld.ml[i].mode;
            if (ld.ml[i].exp_date_index == -1)
               iml[i].index = 3;
            else
               iml[i].index = ld.ml[i].exp_date_index;
            iml[i].nm = (~iml[i].mode) & 3;
            iml[i].ni = (~iml[i].index) & 3;
            iml[i].mxi = (iml[i].mode ^ iml[i].index) & 3;
         }
         
         if ((ld.serial_char[0] >= 'A') && (ld.serial_char[0] <= 'Z'))
            serchar0 = ld.serial_char[0] - 'A';
         else
            serchar0 = ld.serial_char[0] - 'a' + 38;

         if ((ld.serial_char[1] >= 'A') && (ld.serial_char[1] <= 'Z'))
            serchar1 = ld.serial_char[1] - 'A';
         else
            serchar1 = ld.serial_char[1] - 'a' + 38;

         sernum = ld.serial_number;
         version = ld.version;

         auxA = ld.aux_A;
         auxB = ld.aux_B;
         auxC = ld.aux_C;
         
         na = (~auxA) & 255;
         nb = (~auxB) & 255;
         nc = (~auxC) & 7;
      }
      
      /*String convertToString ()
      {              
         // stuff fields into 6-bit values 
         
         val[0] = (ied[2].check >>> 3) & 7;
         val[0] += (ied[1].check & 7) << 3;
         
         val[1] = ied[0].month & 3;
         val[1] += (iml[5].mode << 2) & 12;
         val[1] += (iml[1].nm << 4) & 48;
         
         val[2] = (serchar0 >>> 3) & 7;
         val[2] += (ied[0].year & 7) << 3;

         val[3] = (version & 12) >>> 2;
         val[3] += (iml[0].mode & 3) << 2;
         val[3] += (iml[3].index & 3) << 4;
         
         val[4] = iml[2].mode & 3;
         val[4] += (iml[3].ni & 3) << 2;
         val[4] += (ied[0].day & 24) << 1;
         
         val[5] = sernum & 15;
         val[5] += (iml[5].index & 3) << 4;
         
         val[6] = iml[4].mode & 3;
         val[6] += ied[1].month & 12;
         val[6] += (iml[2].nm & 3) << 4;
         
         val[7] = iml[1].ni & 3;
         val[7] += (ied[2].day & 24) >>> 1;
         val[7] += version & 48;
         
         val[8] = ied[1].month & 3;
         val[8] += (iml[5].ni & 3) << 2;
         val[8] += (iml[0].nm & 3) << 4;
         
         val[9] = serchar0 & 7;
         val[9] += (ied[2].year & 7) << 3;
         
         val[10] = iml[4].ni & 3;
         val[10] += (iml[1].mxi & 3) << 2;
         val[10] += (iml[3].mode & 3) << 4;
         
         val[11] = ied[1].year & 7;
         val[11] += (ied[0].day & 7) << 3;
         
         val[12] = ied[0].check & 7;
         val[12] += (ied[1].day & 7) << 3;
         
         val[13] = iml[1].mode & 3;
         val[13] += (ied[2].year & 24) >>> 1;
         val[13] += (iml[4].mxi & 3) << 4;
         
         val[14] = iml[3].mxi & 3;
         val[14] += (iml[0].ni & 3) << 2;
         val[14] += (ied[2].month & 3) << 4;
         
         val[15] = iml[2].ni & 3;
         val[15] += (version & 3) << 2;
         val[15] += (sernum & 768) >>> 4;
         
         val[16] = iml[0].mxi & 3;
         val[16] += (ied[1].day & 24) >>> 1;
         val[16] += (iml[4].nm & 3) << 4;
         
         val[17] = iml[5].nm & 3;
         val[17] += (iml[2].index & 3) << 2;
         val[17] += (ied[0].year & 24) << 1;
         
         val[18] = iml[0].index & 3;
         val[18] += (iml[5].mxi & 3) << 2;
         val[18] += (ied[0].month & 12) << 2;

         val[19] = (version & 192) >>> 6;
         val[19] += (ied[1].year & 24) >>> 1;
         val[19] += (iml[1].index & 3) << 4;
         
         val[20] = iml[3].nm & 3;
         val[20] += (sernum & 240) >>> 2;

         val[21] = (ied[2].month & 12) >>> 2;
         val[21] += (iml[4].index & 3) << 2;
         val[21] += (iml[2].mxi & 3) << 4;

         val[22] = (ied[0].check >>> 3) & 7;
         val[22] += (ied[2].day & 7) << 3;

         val[23] = (ied[1].check >>> 3) & 7;
         val[23] += (ied[2].check & 7) << 3;

         val[24] = (auxB & 192) >>> 6;
         val[24] += (auxA & 240) >>> 2;
         
         val[25] = nc & 7;
         val[25] += (serchar1 & 7) << 3;

         val[26] = auxA & 3;
         val[26] += (nb & 15) << 2;
         
         val[27] = (serchar1 >>> 3) & 7;
         val[27] += (auxC & 7) << 3;
         
         val[28] = (na & 60) >>> 2;
         val[28] += auxB & 48;
         
         val[29] = (sernum >>> 10) & 15;
         val[29] += (na & 192) >>> 2;

         val[30] = na & 3;
         val[30] += (auxB & 15) << 2;

         val[31] = (auxA & 12) >>> 2;
         val[31] += (nb & 240) >>> 2;
         
         // convert 6-bit values to license string
         
         String string = "";
         
         for (int i = 0; i < 32; i++) {
            String perm = permArray[i];
            string += perm.charAt(((val[hexArray[i]] & 63) + ROLL_PERM_ARRAY) % 64);
            if (i == 31)
               break;
            if ((i % 4) == 3) 
               string += '-';
         }
         
         return string;
      }*/
      
      int LOW3(int i)      { return val[i] & 7; }
      int HIGH3(int i)     { return ((val[i] & 56) >>> 3) & 7; }

      int LOW2(int i)      { return val[i] & 3; }
      int MID2(int i)      { return ((val[i] & 12) >>> 2) & 3; }
      int HIGH2(int i)     { return ((val[i] & 48) >>> 4) & 3; }

      int LOW4(int i)      { return val[i] & 15; }
      int MIDHIGH4(int i)  { return ((val[i] & 60) >>> 2) & 15; }

     InternalLicenseDef (String aLicenseString) throws NumberFormatException
      {
    	 int sum = 0, i, si;
         char sc;
         // verify permArray[] checksum
         
         for (i = 0; i < 32; i++) {
            String perm = permArray[i];
            for (int j = 0; j < 64; j++)
               sum += (int)perm.charAt(j);
         }
         if (sum != PERM_ARRAY_CHECKSUM)
            throw new NumberFormatException("checksum error");
         
         // convert license string to 6-bit values

         if ((aLicenseString.length() != 39) || (aLicenseString.charAt(4) != '-') || (aLicenseString.charAt(9) != '-') || (aLicenseString.charAt(14) != '-') || (aLicenseString.charAt(19) != '-') || (aLicenseString.charAt(24) != '-') || (aLicenseString.charAt(29) != '-') || (aLicenseString.charAt(34) != '-'))
            throw new NumberFormatException("malformed string");
         
         for (i = si = 0; i < 32; i++, si++) {
            String perm = permArray[i];
            int pi;
            if ((sc = aLicenseString.charAt(si)) == '-')
               sc = aLicenseString.charAt(++si);
            if ((pi = perm.indexOf(sc)) == -1)
               throw new NumberFormatException("invalid string");
            val[hexArray[i]] = (pi - ROLL_PERM_ARRAY) % 64;
         }
         
         // extract fields from 6-bit values
         
         ied[0].day = HIGH3(11) + (HIGH2(4) << 3);
         ied[0].month = LOW2(1) + (HIGH2(18) << 2);
         ied[0].year = HIGH3(2) + (HIGH2(17) << 3);
         ied[0].check = LOW3(12) + (LOW3(22) << 3);
        
         ied[1].day = HIGH3(12) + (MID2(16) << 3);
         ied[1].month = LOW2(8) + (MID2(6) << 2);
         ied[1].year = LOW3(11) + (MID2(19) << 3);
         ied[1].check = HIGH3(0) + (LOW3(23) << 3);

         ied[2].day = HIGH3(22) + (MID2(7) << 3);
         ied[2].month = HIGH2(14) + (LOW2(21) << 2);
         ied[2].year = HIGH3(9) + (MID2(13) << 3);
         ied[2].check = HIGH3(23) + (LOW3(0) << 3);
         
         iml[0].mode = MID2(3);
         iml[0].index = LOW2(18);
         iml[0].nm = HIGH2(8);
         iml[0].ni = MID2(14);
         iml[0].mxi = LOW2(16);
         
         iml[1].mode = LOW2(13);
         iml[1].index = HIGH2(19);
         iml[1].nm = HIGH2(1);
         iml[1].ni = LOW2(7);
         iml[1].mxi = MID2(10);
         
         iml[2].mode = LOW2(4);
         iml[2].index = MID2(17);
         iml[2].nm = HIGH2(6);
         iml[2].ni = LOW2(15);
         iml[2].mxi = HIGH2(21);
         
         iml[3].mode = HIGH2(10);
         iml[3].index = HIGH2(3);
         iml[3].nm = LOW2(20);
         iml[3].ni = MID2(4);
         iml[3].mxi = LOW2(14);
         
         iml[4].mode = LOW2(6);
         iml[4].index = MID2(21);
         iml[4].nm = HIGH2(16);
         iml[4].ni = LOW2(10);
         iml[4].mxi = HIGH2(13);
         
         iml[5].mode = MID2(1);
         iml[5].index = HIGH2(5);
         iml[5].nm = LOW2(17);
         iml[5].ni = MID2(8);
         iml[5].mxi = MID2(18);
        
         serchar0 = LOW3(9) + (LOW3(2) << 3);
         serchar1 = HIGH3(25) + (LOW3(27) << 3);
         
         sernum = LOW4(5) + (MIDHIGH4(20) << 4) + (HIGH2(15) << 8);
         sernum += (LOW4(29) << 10);
         
         version = MID2(15) + (LOW2(3) << 2) + (HIGH2(7) << 4) + (LOW2(19) << 6);
         
         auxA = LOW2(26) + (LOW2(31) << 2) + (MIDHIGH4(24) << 4);
         auxB = MIDHIGH4(30) + (HIGH2(28) << 4) + (LOW2(24) << 6);
         auxC = HIGH3(27);
         
         na = LOW2(30) + (LOW4(28) << 2) + (HIGH2(29) << 6);
         nb = MIDHIGH4(26) + (MIDHIGH4(31) << 4);
         nc = LOW3(25);
         
         // check ied fields
         
         boolean error = false;
         
         for (i = 0; i < 3; i++) {
            if (ied[i].month == 13) {
               if (ied[i].year != (~ied[i].day & 31)) {
                  error = true;
                  break;
               }
            } else {
               if (ied[i].day == 0) {
                  error = true;
                  break;
               }
               if (ied[i].month > 11) {
                  error = true;
                  break;
               }
            }
            if (ied[i].check != ((((ied[i].day << 1) ^ ied[i].year) | ~(ied[i].month)) & 63)) {
               error = true;
               break;
            }
         }
         
         if (error)
            throw new NumberFormatException("invalid exp date");
         
         // check iml fields
                  
         for (i = 0; i < 6; i++) {
            if (iml[i].nm != (~iml[i].mode & 3)) {
               error = true;
               break;
            }
            if (iml[i].ni != (~iml[i].index & 3)) {
               error = true;
               break;
            }
            if (iml[i].mxi != ((iml[i].mode ^ iml[i].index) & 3)) {
               error = true;
               break;
            }
         }
         if (error)
            throw new NumberFormatException("invalid module license");
                
         // check serial fields
         
         if ((serchar0 > 25) && (serchar0 < 38))
            error = true;
         else if ((serchar1 > 25) && (serchar1 < 38))
            error = true;
         else if ((sernum < 1) || (sernum > 9999))
            error = true;
         if (error)
            throw new NumberFormatException("invalid serial number");
   
         // check aux fields
         
         if (na != (~auxA & 255))
            error = true;
         else if (nb != (~auxB & 255))
            error = true;
         else if (nc != (~auxC & 7))
            error = true;
         if (error)
            throw new NumberFormatException("invalid aux values");
   
      }
   
      public void convertToLicenseDef (LicenseDef ld)
      {
         int i;
         
         for (i = 0; i < 3; i++) {
            if (ied[i].month == 13)
               ld.ed[i] = new ExpDate();
            else
               ld.ed[i] = new ExpDate(ied[i].year + ExpDate.BASE_YEAR, ied[i].month + 1, (31 - ied[i].day) + 1);
         }
         
         for (i = 0; i < 6; i++) {
            ld.ml[i].mode = iml[i].mode;
            if (iml[i].index == 3)
               ld.ml[i].exp_date_index = -1;
            else
               ld.ml[i].exp_date_index = iml[i].index;
         }
   
         if (serchar0 <= 25)
            ld.serial_char[0] = (char)(serchar0 + 'A');
         else
            ld.serial_char[0] = (char)(serchar0 - 38 + 'a');
         
         if (serchar1 <= 25)
            ld.serial_char[1] = (char)(serchar1 + 'A');
         else
            ld.serial_char[1] = (char)(serchar1 - 38 + 'a');

         ld.serial_number = sernum;
         ld.version = version;

         ld.aux_A = auxA;
         ld.aux_B = auxB;
         ld.aux_C = auxC;           
      }
   }
   
   // convert 'this' into an InternalLicenseDef, then
   // turn that internal representation into a license string
  /* public String encode ()
   {
      InternalLicenseDef ild = new InternalLicenseDef(this);
      return ild.convertToString();
   }*/
   
// obtain an InternalLicenseDef from given license string,
   // then convert that internal representation to 'this'
   public void decode (String aLicenseString) throws NumberFormatException
   {
	  InternalLicenseDef ild = new InternalLicenseDef(aLicenseString);
      ild.convertToLicenseDef(this);
   }
   
   public static String scrambleLicenseString (String aLicenseString) throws NumberFormatException
   {
      if ((aLicenseString.length() != 39) || (aLicenseString.charAt(4) != '-') || (aLicenseString.charAt(9) != '-') || (aLicenseString.charAt(14) != '-') || (aLicenseString.charAt(19) != '-') || (aLicenseString.charAt(24) != '-') || (aLicenseString.charAt(29) != '-') || (aLicenseString.charAt(34) != '-'))
         throw new NumberFormatException("malformed string");
      
      String string = "";
         
      for (int i = 0; i < 32; i++) {
         int j = hexArray[31 - i];
         string += aLicenseString.charAt(j + j / 4);
         if (i == 31)
            break;
         if ((i % 4) == 3) 
            string += '-';
      }
         
      return string;
   }
   
   public static String unscrambleLicenseString (String aLicenseString) throws NumberFormatException
   {
      if ((aLicenseString.length() != 39) || (aLicenseString.charAt(4) != '-') || (aLicenseString.charAt(9) != '-') || (aLicenseString.charAt(14) != '-') || (aLicenseString.charAt(19) != '-') || (aLicenseString.charAt(24) != '-') || (aLicenseString.charAt(29) != '-') || (aLicenseString.charAt(34) != '-'))
         throw new NumberFormatException("malformed string");
      
      String string = "";
      
      for (int i = 0; i < 32; i++) {
         for (int j = 0; j < 32; j++) {
            if (i == hexArray[31 - j]) {
               string += aLicenseString.charAt(j + j / 4);
               break;
            }
         }
         if (i == 31)
            break;
         if ((i % 4) == 3) 
            string += '-';
      }
         
      return string;
   }
}
